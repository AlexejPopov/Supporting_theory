#include <iostream>
#include <locale.h>
#include <stdlib.h>
#include <windows.h>
using namespace std;

/* Т.к. в компьютере у нас находятся только 1 и 0, все с чем работает пользователь преобразуется в последовательность из 1 и 0. Целые числа преобразуются способом деле-
ния и берется остаток от деления, вещественные числа представляются в экспоненциальной форме где сначала берется целая часть, а потом дробная. А с символами используют-
ся кодовые страницы - кодовые таблицы, показывающие нам, какой код (набор из 1 и 0) соответствует конкретной букве/символу. Например букве А соответствует код 1000001,
и так у каждого символа. Их запоминать не нужно, их можно найти если потребуется.

У каждой программы, работающей с текстом и/или с символами есть своя кодировка.
Самая основная латинская кодировка называется ASCII (American standard code for information interchange). Их много, даже каждая страна имеет свои кодировки. Каждая
программа, работающая с символами содержит какую-то кодировкую. Все символы делятся на следующие группы:

1. Управляющие символы (их 32 штуки)
   Они не имеют записи, их нельзя набрать с клавиатуры или вывеси на экран, мы их не увидим. Это такие символы как Esc, Delete, Backslashend, файловые разделители...

2. Печаные символы (символы на клавиатуре)
   Страчная буква и заглавная это разные символы, они имею разные коды. Русские символы тоже имеют свои коды в зависимости от кодировки! А латинские символы присутству-
   ют практически во всех кодировках и имеют те же самые коды, поэтому одни и те же латинские символы отображаются одинаково в разных кодировках и программах.

   Как работает перевод:
   Откроем для наглядности блокнот, напишем "Привет, Мир!". Блокнот, в соответствии со своей кодировкой переводит каждую букву/символ отдельно в последовательность из 1
   и 0, получается длинный ряд из 1 и 0. И в таком виде он сохраняется в память. А если мы этот текст, созданный в блокноте, попробуем открыть в другой программе, в ко-
   торой другая кодировка, то другая программа нашу последовательность из 1 и 0 преобразует в текст в соответствии со своей кодировкой. А в ее кодировке нашей последо-
   вательности из 1 и 0 могут соответствовать другие символы, скажем "язык дьявола". Почему так?

   Наша переменная char может содержать всего 255 символов, поэтому коды всех кодировок вмещают от 0 до 255, либо от -128 до +127 (ноль включительно). А переменная char
   вмещает всего 1 байт (за искл. некоторый китайских или подобных 2-х байтовых расширенных кодировок). А т.к. у нас всего 255 символов в любой кодировке, в которую мы
   должны поместить символы (и русские, и нерусские), след, каждая кодировка должна содержать лишь 255 самых нужных символов, необходимых для конкретной задачи/локации
   и прочих требований. След, кодировки тем и отличаются - набором символов и соответствующим им двоичным кодом. Мы пересылаем 1 и 0, а каждая программа их воспринимает
   по-своему, в зависимости от того какая в ней установлена кодировка.

   Виды кодировок:
   Штатная русская кодировка ОС Windows это Windows-1251. Есть рекомендации для стран, регионов по кодировкам, но все же каждая программа может работать с той кодиров-
   кой, с которой нужно. Некоторые программы содержат несколько кодировок и могут переключаться между ними, например, почтовый клиент. Если необходимо, то можно перек-
   лючить кодировку чтобы правильно отобразить полученную последовательность из 1 и 0. Самые известные кодировки: ANSI, UTF-8, региональные кодировки... На кириллицу
   только 8 кодировок: на IOS кодировка Macintosh, KOI8-R - одна из стандартных русских кодировок, используемая большинством почтовых клиентов, серия OEM 855 (старее)
   и OEM 866 (новее) кодировки, пришедшие к нам из OS DOS. В Линуксе тоже есть свои кодировки, но устроены они там иначе и удобнее.


   Чтобы у нас все работало, нам нужно соответствие кодировок. В операционной системе стоит одна кодировка, а вот в программах, которые мы пишем (например в той же сту-
   дии), стоит другая кодировка. А когда мы еще запускаем консоль (командную строку) где работает наша программа, в которой по умолчанию стоит своя кодировка командной
   строки, след, у нас все кодировки разные: в операционной системе, в студии, и даже в консоли!
   (!) командная строка это урезанный и внедренный в ОS Windows интерфейс от MS DOS.


   Как установить соответствие кодировок, есть несколько возможностей:

   1. Мы можем наш проект сохранить с нужной нам кодировкой: сохранить файл КАК -> (при сохранении выбрать, у кнопки сохранить, стрелочку вниз и выбрать сохранить с ко-
   дировкой...), выбрать нужную кодировку.
   Но это поможет лишь тогда, когда нам нужно этот исходник открыть в ДРУГОЙ программе, которая поддерживает нужную кодировку. Это в своем роде выхлоп с нужной кодиров-
   кой исходного файла, а в самой студии соответствие кодировок установлено не будет.

   2. Рассмотрим как можно установить соответствие в студии. У нас есть два потока: ввод и вывод. Когда мы вводим с клавиатуры символы, консоль преобразует их в последо-
   вательность из 1 и 0, а дальше мы этот код (с помощью оператора cin) помещаем в память, которую выделили для его хранения. Пример внизу в коде. */


int main()
{
    /*
    SetConsoleOutputCP(1251);
    SetConsoleCP(1251);

    Установка кодовой страницы - Set Console Output Code Page скажет, что при работе с консолью наша программа должна выводить символы в соответствии с новой кодировкой
    1251. SetConsoleOutputCP работает только на вывод символов, а SetConsoleCP работает на ввод. Можно подключать что-то одно, если другое использоваться не будет. */

    system("chcp 1251");                          // установка кодовой страницы 1251 средствами самой консоли, и на ввод, и на вывод.
    system("cls");                                // (!) она выводит на экран пометку о кодовой странице, поэтому нам нужно с этой командой использовать очистку экрана!

    /*
    setlocale(LC_ALL, "rus");                       // в среде Windows и только для вывода текста на экран!
    */
    cout << "Привет, Мир!" << endl;
    char Symbol = '+';                              // char может хранить от 0 до 255 или от -128 до +127 (в старой кодировке от 0 до 127)
    cout << "Введите символ: "; cin >> Symbol;
    cout << "Символ: " << Symbol << endl;
    /* Букву 'Щ' мы увидели, т.к. когда мы в консоли набираем букву 'Щ', буква 'Щ' в 866 кодировке имеет код 153, переведем это число в двоичный код и получим 10011001.
    Далее этот код мы помещаем в Symbol. A char занимает в памяти 1 байт, выделенный нам операционной системой, т.е. 1 байт = 8 бит (8 ячеек, 8 единичек и нулей), и ту-
    да мы запишем наши 8 единичек и ноликов, соответствующих букве 'Щ'. А затем, когда мы вызовим команду cout и выведем на экран содержимое переменной Symbol, команда
    cout берет из памяти содержимое переменной Symbol (код 10011001) и отправляет в консоль, а консоль эту последовательность получает и преобразует в соответствии с
    той же 866 кодировкой в букву 'Щ'.

    А как наша программа, не консоль, а именно наша программа (благодаря Студии) воспринимает этот символ. Напишем проверку if else. */

    if (Symbol != 'Щ')cout << "It's not SCH!" << endl;
    else cout << "Это буква Щ!" << endl;
    cout << "Символ: " << Symbol << endl;

    /* Наша программа букву 'Щ' воспринимает ни как 'Щ', т.к. наша программа в студии написана в кодировке UTF-8, а в этой кодировке букве 'Щ' принадлежит другой двоич-
    ный код 10101000. Т.к. и консоль, и студия используют разные кодировки, мы получаем другой символ. Что же нам делать? Несоответствие кодировок той среды, в которой
    запущена наша программа (консоль), и той, какая кодировка используется в нашей программе, создают проблему. Чтобы решить проблему нужно чтобы при сравнении (Symbol
    != 'Щ'), у 'Щ', написанного внутри нашей программы, и у Symbol, который мы ввели с клавиатуры была одинаковая кодировка. Сделаем так.

    Добавим функцию setlocale(LC_ALL, "rus"); и видим только "Привет, Мир!", а букву 'Щ' не видим. Станет лишь еще запутаннее, т.к. команда setlocale не меняет кодовую
    страницу, даже буква стала другая, она вмешивается в работу, изменяя набор данных как часов.пояс, геолокация, наличие языка, время,... Она пытается сказать, что мы
    находимся в России, а след, для этого нужно использовать кодировки, которые приняты для России, и т.о. функция пытается найти что-то среднее между кодировкой консо-
    ли и кодировкой студии, пытаянь найти что-то среднее.
    Попробуем убедиться что она не меняет кодировку в нашей консоли, а пытается найти "общий знаменатель". У консоли в запущенной программе по прежнему осталась прежняя
    кодировка. Функция пытается для консоли, и для студии сказать, что мы в России и связывает их. Для студии получается, а для консоли нет. Пытаясь поменять кодировку
    для консоли, функция не справляется и меняет символы, которые мы вводим, т.е. она пытается то, что мы передаем из консоли интерпретировать в удобный вариант для на-
    шей программы (для кодировки из студии), и обратно, что мы выводим пытается интерпретировать, пытаясь найти им общий знаменатель. И мы видим, что в Windows на вывод
    это работает, а на ввод нет. Т.о. setlocale(LC_ALL, "rus") мы используем только для вывода текста на экран и для нашей программы она все подправит в русский сегмент.
    А в Линуксе все работает и на ввод, и на вывод!
    (В Линуксовых компиляторах уже сразу стоит поддержка русского текста, т.к. там Терминал, а не консоль. И как работать с Терминалом компиляторы для Линукса знают и
    сразу настраивают единую локаль при установке русской версии системы в Терминале, и во всех программах. И если вдруг это не случится, то команда setlocale там все
    поправит. Она там работает в обе стороны, и на ввод, и на вывод, т.к. локализация это понятие в первую очередь Линуксовое в виде setlocale(LC_ALL, "rus").

    Что нам сделать чтобы и вводился русский текст корректно?

    1. Договориться с самой консолью на языке, понятной ей.
    У консоли есть команды, пришедшие из времен DOS, например, команда ping (проверка доступности узла), копировать, создавать файл, а также команда для смены кодировки
    chcp (команда покажет текущую кодировку в консоли/командной строке)
    chcp 1251 (команда сменит текущую кодировку на 1251)
    Здесь мы просим консоль сменить себе коировку.

    2. а) Для OS Windows есть спец.команды из OS Windows, расположенные в спец.библиотеках. Мы попросим OS Windows самой сменить кодировку консоли средствами языка прог-
    раммирования из библ. windows.h. В windows.h есть команды для работы с консолью, и для использования других механизмов OS, а т.к. консоль часть OS, мы можем их ис-
    пользовать!

    SetConsoleOutputCP(1251); - команда устанавливает кодировку 1251 для консоли на вывод из нашей программы в консоль.
    SetConsoleCP(1251); - команда устанавливает кодировку 1251 для консоли на ввод из консоли (эти две команды идут парой)

    Если нам нужно сменить кодировку только на вывод символов, то мы можем использовать лишь первую строчку.
    (!) Кодировку лучше ставить такую, как и у OS Windows, чтобы не было разногласий с другими программами OS Windows.

       б) Та же команда, но из другой библиотеки stdlib.h
    system("chcp 1251");
    Команда system позволяет использовать команды консоли, те самые команды, которые в консоли и работают и пришли к нам еще с DOS и были написаны на чистом 'C'.

    Какую команду(-ы) лучше взять?
    Ту, библиотека которой уже подключена к программе, т.к. подключение новой библиотеки займет еще место в памяти, и лучше использовать каждую подключенную библиотеку
    по-максимуму!
    А если нам нужно вывести только русский текст на экран, а не вводить его в программу, то лучше всего locale.h, т.к. сама команда кросс-платформенная, да и библиоте-
    ка там поменьше весит, да и сама команда чуть шустрее.


       Заключение: если вдруг нам понадобятся какие-то другие символы, китайские, арабские или еще какие-то, то нам нужно:

    1. Чтобы они были в самой операционной системе (чтобы мы могли их ввести с клавы), иметь необходимый язык в системе.
    2. Чтобы программа могла с этими символами работать как нам надо, нужно ввести соответствующуу кодировку (коды кодировок есть в интернете)
    3. Все 3 варианта выше никак друг другу не мешают, можно хоть все три написать сразу, но бессмысленно одно и тоже прописывать три раза!
    4. Каждый из вариантов выше требует подключения своей библиотеки, в которой конкретная команда содержится!

    (!) Команды с началом system работают только в OS Windows, т.к. пришли сюда еще из OS DOS */
}