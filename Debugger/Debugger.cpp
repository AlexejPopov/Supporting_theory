#include <iostream>
#include <locale.h>
using namespace std;

/* Существуют два вида ошибок, на этапе компиляции и на этапе выполнения. Вторые самые проблемные, могут приводить к неправильной логике программы или же ошибкам запуска и прочее.
Их можно предвидеть с помощью проверки пользовательского ввода, например не допустить деление на 0. В среде разработки также есть такая функция - отладчик, которая позволяет пос-
мотреть что происходит в нашей программе в тот или иной момент времени при ее выполнении. Отладчик позволяет нам при выполнении программы посмотреть что происходит с функциями,
переменными, массивами, со всем с чем мы работаем.
У отладчика есть 2 режима:
  I * работа по шагам - выполнение программы строчка за строчкой (как это делает компилятор)
      Гор.клавиша F10 или Debug -> Step Over (Шаг с обходом (функций)).
      Консоль мигает, программа на паузе. Желтая стрелочка показывает следующую строку выполнения. Мы запстили программу, но перед запуском ее спера срабатывает компилятор, он
      проверяет на наличие ошибок, переводит код в машинный язык и запрашивет выделение памяти под переменный (int 4 байта, double 8 байт, след. 16 байт), компилятор запрашивает
      16 байт у операц.системы, операц.система выделяет память и после только этого мы заходим в нашу программу и она запускается. Поэтому под переменные А и В место выделено, мы
      пока не можем с ними работать, но место под них уже зарезервировано под нашу программу. И так под все объекты, под которые мы будем запрашивать память, выделяя ее с помощью
      объявлений int, float, char, double... (Создание переменных это запрос на выделение памяти нужного объема).
      Внизу появились вкладки | Autos | Locals | Watch 1 |
      Watch 1 позволяет добавить в нее какую-то переменную, объект и следить за ним на протяжении всего срока жизни.
      Locals показывает все объекты, которые созданы/будут созданы в нашей области видимости. На данный момент все, что создано в нашей функции main.
      Autos (Видимые) показывает какие объекты доступны в той строчке, на которой стоит желтая стрелка.
      F10 перемещает желтую стрелку вниз.
      В Locals я вижу созданные переменные, точнее выделенную память под них, пока там лежит мусор. Чтобы с переменными что-то сделать, их нужно объявить (или дойти до их объявления
      стрелочкой). Нажмем F10, стрелка переместится в объявление переменных, еще раз F10 и в Видимом уже появилась переменная А, локализация, в Locals у А и В появились красные нули
      и переменная С по прежнему с мусором. Красные цифры показывают, что было изменено значение, т.к. выполнив строчку (int A = 0, B = 0;) мы их объявили! И так построчно, еще раз
      F10 и мы уже видим в консоли строку (Введите число А: ), мы вводим, видим, что в Видимом и Локальном данные тоже обновились! Еще раз F10, дав в В 0 например, отладчик выдаст
      ошибку! Отладчик нашел ошибку в ячейке памяти где наша программа и пояснил вид ошибки - деление на ноль!
      Как можно ошибку исправить?
      В колонке Value мы можем менять значение переменных, двойной клик и введем новое значение. Отладчик позволяем корректировать и увидеть как поведет себя программа если мы устраним
      программу прямо сейчас, заново ее не запуская.
      SHIFT+F5 - выход из отладчика.

    * выборочная проверка конкретной строки. Мы должны взять желтую стрелку и перетащить ее в нужную строку, игнорируя все команды, которые остались пропущенными. Вводим вручную в
      Видимой части значения для А и В и получаем новое число в консоли (при старых значениях А и В).
      (!) при перемещении стрелочки вниз принудительно, мы пропускаем выполнение пропущенных строк, например, русский текст выводиться не будет из-за пропуска setlocale. С другой
      стороны при перемещении стрелки вверх мы рискуем получить неправильные значения. Что же в таком случае делать?

 II * запуск программы с отладкой F5. Это такой же запуск программы как и Ctrl+F5, но при этом работает отладчик. Если что-то пойдет не так, то сработает отладчик. Если при запуске с
      отладчиком обнаружится такая же ситуация с делением на ноль, то вместо вылета с ошибкой, отладчик остановит выполнение программы, перейдет в режим отладки и переключит нас в
      интерфейс отладки и мы сможем посмотреть что же произошло и что идет не так!
      (!) Отладчик игнорирует недочеты, как например неявное преобразование с отбросом дробной части и подобные вещи, т.к. они вполне легитимны с точки зрения работы программы.

      Что еще мы можем тут сделать? Чтобы нам каждый раз пошагово не ходить, мы можем сделать чтобы отладчик запускался в люб.случае. Например, мы вводим деление на ноль и программа
      отрабатывает, получается inf (переполнение), т.к. в double можно деление на ноль сделать, будет, грубо говоря, бесконечность, но ошибки уже не будет. А нам не нужно чтобы такая
      ситуация пропускалась. Бесконечность это не результат! Нам нужно поставить точку остановы. А именно это команда отладчику остановиться в конкретной строке в люб.случае/порядке.
      Мы ставим точку остановы, запускаем программу по F5 и компилятор остановится в точке остановы в люб.случае обязательно. А именно выполнение закончится ПЕРЕД строкой с точкой!
      Точка ставится клавишей F9 для той строки, где размещен курсор или же кликнуть мышкой на то место где она должна быть для нужной строки. Их можно ставить сколько угодно. Остано-
      вившись на точке остановы, дальше в отладчике мы можем продолжить движение, нажимая F10 и между продолжить движение строчка за строчкой. А можем снова нажать F5 и тогда программа
      продолжит работу, начиная с этой точки остановы до конца (или до следующей точки остановы). А потом мы можем уже нажать и выход из отладки, или нажать F5 чтобы программа до конца
      доработала или снова нажать F10 или продолжить выполнять по строчкам и т.д. Т.е. прервет выполнение программы, запущенной в режиме отладки в начале выбранной строчки, а далее с F10
      можно продолжить отладку по строчкам либо что-то подкорректировать, посмотреть значения переменных, снова нажать F5 и продолжить выполнение программы в обычном режиме, но в отладке!
      Убрать точку остановы можно также как и поставить.

      Но нам надо останавливаться в строке с double не каждый раз а только когда B==0, для этого существует УМНАЯ ТОЧКА ОСТАНОВЫ. Это такая точка, которой мы можем задать условие. Т.е.
      не каждый раз тормозить отладчик, а только тогда, когда какое-то условие произошло, что-то пошло не так.
      Ставим точку остановы, наводим на нее мышь, ПКМ -> Conditions (или поднеся мышку нажать на шестерню и там кликнуть Условия). Пропишем там условие скажем B==0 и закроем окно редактора.
      Если В не будет равно нулю, то все выполнится как надо, а если В будет равно нулю, точка остановы сработает и переведет нас в отладку на корректировку. Исправить и например снова на-
      жать F5 чтобы программа завершила выполнение.
      (!) если программу запустить без отладки, но с точками остановы, то никакой отладки у нас не будет.
      (!) нельзя точку остановы держать активной в закоментированном коде, нужно ее удалить либо отключить, нажав на нее ПКМ.

      Точка остановы может прервать не только программу, но и цикл. Прервать на выбранной итерации, посмотреть как цикл работает, нет ли в нем сбоев, все ли правильно, а дальше просто нажать
      F5 и цикл дальше продолжит свою работу как ни в чем не бывало. Отладчик позволяет нам понять что происходит в нашей программе на том или ином действии и вручную контролировать работу
      программы, пошагово или останавливая ее в нужный момент, проверяя значения всех переменных и то, как у нас все работает. Рассмотрим простенький цикл ниже.
      Если я хочу проследить за выполнением моей программы (особенно если итераций очень много), зайдем в отладку F10 и по шагам будем двигаться. В Видимом виже счетчик i, он ограничен скоб-
      ками цикла. Я хочу проследить за счетчиком, для этого я могу к люб.переменной подвести окошечко наблюдений, подвести мышку к переменной и оно появится (могу еще нажать на скрепку и оно
      будет закреплено. Можно его будет переместить куда-нибудь где будет удобно следить за значением переменной (аналог того что мы видим снизу). Я хочу уделить пристальное внимание той ите-
      рации, когда счетчик равен 5. Жмем F10, снова F10 и так жмем до тех пор пока i будет равно 5. А когда дошел, не успел и оно вывелось на экран, а я хотел посмотреть сначала действие вывода.
      Целых 5 итераций и одну проскочил. А если их 150 или еще больше, то это очень неудобно. Если мне нужно изучить какой-то конкретный шаг в цикле подробно, а оно уже выполнилось и я опоздал,
      придется заново заходить в отладчик и заново все это выполнять не вариант. Тут необходимо добавить умную точку остановы, чтобы остановиться не только в момент какой-то нештатной ситуации,
      но и внутри цикла на каком-то моменте. Я ставлю точку остановы ПЕРЕД ВЫВОДОМ НА ЭКРАН и задаю условие точки (если i==5) и получаю точку остановы, которая прервет мой цикл, когда счетчик i
      равен 5 чтобы посмотреть пятую итерацию. Теперь, запускаю программу просто по F5 и вижу, что были отработаны шаги, которые до точки остановы, а именно до того как i стала равна 5, а на
      пятой строчке у нас какое-то сложное действие (отдельная команда) и мне хочется посмотреть как оно сработает в контексте всего цикла или просто притормозить на каком-то нужном шаге и т.д.
      А потом еще раз нажимаю F5 и программа выполняется до конца либо идти по шагам по F10.

      Есть еще одно преимущество работы с отладчиком - мы видим не конечный результат программы, а можем посмотреть как мы получили этот конечный результат.
      Рассмотрим цикл со switch, т.к. при выполнении кода мы видим только результат, мы не видим как он выполняется, правильный ли. Тут мне поможет отладчик,
      позволяющий мне пройти по шагам, посмотреть как сработает программа/цикл, каждый шаг. */

int main()
{
    setlocale(LC_ALL, "rus");
    /*
    int A = 0, B = 0;
    cout << "Введите число А: "; cin >> A;
    cout << "Введите число В отличное от нуля: "; cin >> B;
    double C = A / B;
    cout << "Результат С= " << C << endl;
    */
    /*
    for (int i = 0; i < 10; i++)
    {
        //if(i==5)cout<<"Yes!"<<endl;
        cout << "i*i= " << i * i << endl;
    }
    */
    int i = 0;
    for (; i < 4; ++i)
    {
        switch (i)
        {
        case 0:cout << "0";
        case 1:cout << "1"; continue;
        case 2:cout << "2"; break;
        default:cout << "D"; break;
        }
        cout << ".";
    }
    /* Я посчитал 01.1.2.D.
    Правильный ответ 0112.D.
    Я поставил лишние точки после 1, т.к. не учел что continue не работает на switch и на if else, а работает только на цикл, след, оно пропустит не только что во switch, а все в цикле
    (и ту точку, которая выводится после switch). Т.е. как только будет выполнена команда continue, мы пропустим все ниже от нее в цикле for и снова перейдем в параметры цикла и увеличим
    счетчик.
    (!) break срабатывает на ближайшую конструкцию с которой может работать (в нашем случае на switch), а continue выводит к следующему шагу цикла! */
}